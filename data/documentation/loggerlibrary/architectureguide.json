{"metadata":{"role":"article","roleHeading":"Article","color":{"standardColorIdentifier":"blue"},"modules":[{"name":"LoggerLibrary"}],"title":"Architecture Guide"},"kind":"article","variants":[{"paths":["\/documentation\/loggerlibrary\/architectureguide"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/ArchitectureGuide"},"sections":[],"abstract":[{"type":"text","text":"Understand the protocol-first architecture and how to structure logging in modular applications."}],"primaryContentSections":[{"content":[{"anchor":"Overview","type":"heading","level":2,"text":"Overview"},{"inlineContent":[{"type":"text","text":"LoggerLibrary is designed around a protocol-first architecture that promotes loose coupling, testability, and flexibility. This guide explains the architectural patterns and best practices."}],"type":"paragraph"},{"anchor":"Protocol-First-Design","type":"heading","level":2,"text":"Protocol-First Design"},{"anchor":"Depend-on-Abstractions","type":"heading","level":3,"text":"Depend on Abstractions"},{"inlineContent":[{"text":"Your modules should depend only on the ","type":"text"},{"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/Logger","isActive":true,"type":"reference"},{"text":" protocol, never on concrete implementations:","type":"text"}],"type":"paragraph"},{"code":["\/\/ ✅ Good: Protocol dependency","import LoggerLibrary","","struct FeatureManager {","    let logger: Logger  \/\/ Protocol type","}","","\/\/ ❌ Bad: Concrete dependency","import LoggerLibrary","","struct FeatureManager {","    let logger: PrintLogger  \/\/ Concrete type","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This keeps your modules independent and testable.","type":"text"}],"type":"paragraph"},{"anchor":"Domain-Organization","type":"heading","level":2,"text":"Domain Organization"},{"anchor":"Module-Level-Domains","type":"heading","level":3,"text":"Module-Level Domains"},{"inlineContent":[{"text":"Each module defines its own logging domains as extensions to ","type":"text"},{"type":"reference","identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/LoggerDomain","isActive":true},{"text":":","type":"text"}],"type":"paragraph"},{"code":["\/\/ NetworkingModule\/LoggerDomain+Networking.swift","import LoggerLibrary","","extension LoggerDomain {","    static let network: LoggerDomain = \"Network\"","    static let api: LoggerDomain = \"API\"","}","","\/\/ DatabaseModule\/LoggerDomain+Database.swift","import LoggerLibrary","","extension LoggerDomain {","    static let database: LoggerDomain = \"Database\"","    static let persistence: LoggerDomain = \"Persistence\"","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Benefits","type":"heading","level":3,"text":"Benefits"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Natural Namespacing"}]},{"text":": Domains are scoped to their modules","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Type Safety","type":"text"}],"type":"strong"},{"type":"text","text":": Static properties prevent typos"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Discoverability"}]},{"type":"text","text":": Xcode autocomplete shows available domains"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"No Conflicts","type":"text"}]},{"type":"text","text":": Multiple modules can safely define domains"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Centralized-Configuration","type":"heading","level":2,"text":"Centralized Configuration"},{"inlineContent":[{"type":"text","text":"The app layer imports all modules and sees all their domains, enabling centralized logger configuration:"}],"type":"paragraph"},{"code":["\/\/ App layer","import LoggerLibrary","import NetworkingModule  \/\/ Brings .network, .api","import DatabaseModule    \/\/ Brings .database, .persistence","","let logger = DomainFilteredLogger(","    defaultLogLevel: .info,","    domainLogLevels: [","        \/\/ Control each module independently","        .network: .debug,","        .api: .verbose,","        .database: .info,","        .persistence: .warning","    ]",")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This pattern allows you to:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Debug specific subsystems without noise from others"}]}]},{"content":[{"inlineContent":[{"text":"Configure logging per environment (debug vs. release)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Change logging strategy without modifying module code"}]}]}],"type":"unorderedList"},{"anchor":"Custom-Logger-Implementations","type":"heading","level":2,"text":"Custom Logger Implementations"},{"anchor":"Single-Backend-Logger","type":"heading","level":3,"text":"Single-Backend Logger"},{"inlineContent":[{"type":"text","text":"Create loggers for specific backends:"}],"type":"paragraph"},{"code":["import os.log","","struct OSLogger: Logger {","    private let osLog = OSLog(subsystem: \"com.app\", category: \"general\")","","    func log(","        _ level: LoggerLevel,","        _ domain: LoggerDomain,","        _ message: @autoclosure @escaping () -> String","    ) {","        let type: OSLogType = switch level {","        case .verbose, .debug: .debug","        case .info: .info","        case .warning, .error: .error","        case .disabled: .default","        }","        os_log(\"%{public}@\", log: osLog, type: type, message())","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Composite-Logger","type":"heading","level":3,"text":"Composite Logger"},{"inlineContent":[{"type":"text","text":"Combine multiple loggers with custom routing logic:"}],"type":"paragraph"},{"code":["struct CompositeLogger: Logger {","    let console = PrintLogger(logLevel: .debug)","    let file = FileLogger()","    let remote = RemoteLogger()","","    func log(","        _ level: LoggerLevel,","        _ domain: LoggerDomain,","        _ message: @autoclosure @escaping () -> String","    ) {","        \/\/ Always log to console","        console.log(level, domain, message())","","        \/\/ Log errors to file and remote service","        if level >= .error {","            file.log(level, domain, message())","            remote.log(level, domain, message())","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Domain-Specific-Router","type":"heading","level":3,"text":"Domain-Specific Router"},{"inlineContent":[{"type":"text","text":"Route different domains to different backends:"}],"type":"paragraph"},{"code":["struct RouterLogger: Logger {","    let analyticsLogger = AnalyticsLogger()","    let consoleLogger = PrintLogger(logLevel: .debug)","","    func log(","        _ level: LoggerLevel,","        _ domain: LoggerDomain,","        _ message: @autoclosure @escaping () -> String","    ) {","        switch domain.description {","        case \"Analytics\":","            analyticsLogger.log(level, domain, message())","        default:","            consoleLogger.log(level, domain, message())","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Testing-Strategies","type":"heading","level":2,"text":"Testing Strategies"},{"anchor":"Use-NoOpLogger-in-Tests","type":"heading","level":3,"text":"Use NoOpLogger in Tests"},{"inlineContent":[{"text":"The ","type":"text"},{"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/NoOpLogger","type":"reference","isActive":true},{"text":" discards all messages, keeping test output clean:","type":"text"}],"type":"paragraph"},{"code":["func testNetworkRequest() {","    let logger = NoOpLogger()","    let manager = NetworkManager(logger: logger)","","    \/\/ Test without log noise","    manager.fetchData()","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Verify-Logging-Behavior","type":"heading","level":3,"text":"Verify Logging Behavior"},{"inlineContent":[{"type":"text","text":"Create a test logger to verify log calls:"}],"type":"paragraph"},{"code":["final class TestLogger: Logger {","    var messages: [(LoggerLevel, LoggerDomain, String)] = []","","    func log(","        _ level: LoggerLevel,","        _ domain: LoggerDomain,","        _ message: @autoclosure @escaping () -> String","    ) {","        messages.append((level, domain, message()))","    }","}","","func testLogsError() {","    let testLogger = TestLogger()","    let manager = NetworkManager(logger: testLogger)","","    manager.handleError()","","    XCTAssertEqual(testLogger.messages.count, 1)","    XCTAssertEqual(testLogger.messages[0].0, .error)","}"],"type":"codeListing","syntax":"swift"},{"anchor":"Environment-Configuration","type":"heading","level":2,"text":"Environment Configuration"},{"inlineContent":[{"type":"text","text":"Configure logging based on build configuration:"}],"type":"paragraph"},{"code":["#if DEBUG","let logger = DomainFilteredLogger(","    defaultLogLevel: .debug,","    domainLogLevels: [","        .network: .verbose,","        .analytics: .disabled","    ]",")","#else","let logger = PrintLogger(logLevel: .warning)","#endif"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Or use environment variables:"}],"type":"paragraph"},{"code":["let logLevel: LoggerLevel = ProcessInfo.processInfo.environment[\"LOG_LEVEL\"]","    .flatMap(LoggerLevel.init(rawValue:)) ?? .info","","let logger = PrintLogger(logLevel: logLevel)"],"type":"codeListing","syntax":"swift"},{"anchor":"Best-Practices","type":"heading","level":2,"text":"Best Practices"},{"anchor":"Do","type":"heading","level":3,"text":"Do"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"✅ Depend on the "},{"type":"reference","identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/Logger","isActive":true},{"type":"text","text":" protocol in modules"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅ Define domains as static properties on "},{"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/LoggerDomain","isActive":true,"type":"reference"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"✅ Use ","type":"text"},{"isActive":true,"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/DomainFilteredLogger","type":"reference"},{"text":" for flexible debugging","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅ Use "},{"type":"reference","identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/NoOpLogger","isActive":true},{"type":"text","text":" in tests"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"✅ Configure logger at the app layer"}],"type":"paragraph"}]}],"type":"unorderedList"},{"anchor":"Dont","type":"heading","level":3,"text":"Don’t"},{"items":[{"content":[{"inlineContent":[{"text":"❌ Import concrete logger types in modules","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"❌ Use string literals for domains"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"❌ Create logger instances in module code","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"❌ Log sensitive information (passwords, tokens)","type":"text"}]}]}],"type":"unorderedList"},{"anchor":"Performance-Considerations","type":"heading","level":2,"text":"Performance Considerations"},{"inlineContent":[{"type":"text","text":"LoggerLibrary uses "},{"type":"codeVoice","code":"@autoclosure"},{"type":"text","text":" for message parameters, ensuring zero-cost when messages are filtered:"}],"type":"paragraph"},{"code":["\/\/ This expensive operation only runs if logged","logger.debug(.network, \"Data: \\(expensiveFormatting(data))\")","","\/\/ If .network is disabled or level < .debug, the closure never executes"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This makes it safe to include detailed debug logging without performance impact in production.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary"]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"references":{"doc://LoggerLibrary/documentation/LoggerLibrary/NoOpLogger":{"url":"\/documentation\/loggerlibrary\/nooplogger","kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NoOpLogger","kind":"identifier"}],"type":"topic","abstract":[{"text":"A no-operation logger that discards all log messages.","type":"text"}],"title":"NoOpLogger","identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/NoOpLogger","navigatorTitle":[{"text":"NoOpLogger","kind":"identifier"}]},"doc://LoggerLibrary/documentation/LoggerLibrary/Logger":{"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/Logger","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Logger","kind":"identifier"}],"title":"Logger","navigatorTitle":[{"text":"Logger","kind":"identifier"}],"url":"\/documentation\/loggerlibrary\/logger","abstract":[{"text":"An protocol for writing interpolated string messages to the unified logging system.","type":"text"},{"text":" ","type":"text"},{"text":"corresponding to a log level.","type":"text"}],"kind":"symbol","type":"topic"},"doc://LoggerLibrary/documentation/LoggerLibrary/LoggerDomain":{"title":"LoggerDomain","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LoggerDomain","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/LoggerDomain","url":"\/documentation\/loggerlibrary\/loggerdomain","role":"symbol","abstract":[{"type":"text","text":"The domain shared by the logs originating from the same "},{"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/Logger","type":"reference","isActive":true},{"type":"text","text":"."}],"navigatorTitle":[{"text":"LoggerDomain","kind":"identifier"}],"kind":"symbol"},"doc://LoggerLibrary/documentation/LoggerLibrary":{"kind":"symbol","title":"LoggerLibrary","role":"collection","type":"topic","identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary","url":"\/documentation\/loggerlibrary","abstract":[{"type":"text","text":"A lightweight, flexible logging framework with domain-based filtering for Swift applications."}]},"doc://LoggerLibrary/documentation/LoggerLibrary/DomainFilteredLogger":{"kind":"symbol","abstract":[{"type":"text","text":"A logger that outputs messages to the console with per-domain log level configuration."}],"identifier":"doc:\/\/LoggerLibrary\/documentation\/LoggerLibrary\/DomainFilteredLogger","title":"DomainFilteredLogger","url":"\/documentation\/loggerlibrary\/domainfilteredlogger","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"DomainFilteredLogger"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"DomainFilteredLogger"}],"role":"symbol"}}}